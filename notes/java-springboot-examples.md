# Java/Spring Boot Examples

## Complete Examples for Java Spring Boot Integration

### Example 1: User Management REST API

This example demonstrates creating a complete user management system with Spring Boot, including entities, repositories, services, controllers, and tests.

#### Feature Specification

```markdown
# User Management API

## Feature Request
Create a comprehensive user management REST API with CRUD operations, validation, and authentication.

## Technical Requirements
- Spring Boot 3.x with Spring Web
- Spring Data JPA for persistence
- Spring Security for authentication
- H2/PostgreSQL database support
- Bean validation for input validation
- Comprehensive error handling
- JWT token authentication
- Unit and integration tests

## Data Model
```json
{
  "User": {
    "id": "Long (auto-generated)",
    "email": "String (unique, validated)",
    "firstName": "String (required, 2-50 chars)",
    "lastName": "String (required, 2-50 chars)",
    "password": "String (encoded, min 8 chars)",
    "roles": "Set<Role> (USER, ADMIN, MODERATOR)",
    "isActive": "Boolean (default true)",
    "createdAt": "LocalDateTime",
    "updatedAt": "LocalDateTime"
  },
  "Role": {
    "id": "Long",
    "name": "String (ROLE_USER, ROLE_ADMIN, etc.)",
    "permissions": "Set<String>"
  }
}
```

## API Endpoints
- GET /api/users - List all users (admin only)
- GET /api/users/{id} - Get user by ID
- POST /api/users - Create new user (registration)
- PUT /api/users/{id} - Update user
- DELETE /api/users/{id} - Delete user (admin only)
- POST /auth/login - User authentication
- POST /auth/refresh - Refresh JWT token

## Business Logic
- Email must be unique across all users
- Password must meet complexity requirements
- Users can only view/edit their own profile (unless admin)
- Soft delete for user removal (mark inactive)
- Audit trail for user modifications

## Testing Requirements
- Unit tests for all service methods
- Integration tests for REST endpoints
- Security tests for authentication/authorization
- Repository tests with @DataJpaTest
- Test coverage minimum 85%
```

#### Generated Code Structure

**Project Structure**:
```
src/
├── main/java/com/example/usermanagement/
│   ├── UserManagementApplication.java
│   ├── config/
│   │   ├── SecurityConfig.java
│   │   ├── JwtConfig.java
│   │   └── DatabaseConfig.java
│   ├── entity/
│   │   ├── User.java
│   │   ├── Role.java
│   │   └── BaseEntity.java
│   ├── repository/
│   │   ├── UserRepository.java
│   │   └── RoleRepository.java
│   ├── service/
│   │   ├── UserService.java
│   │   ├── UserServiceImpl.java
│   │   ├── AuthenticationService.java
│   │   └── JwtService.java
│   ├── controller/
│   │   ├── UserController.java
│   │   └── AuthController.java
│   ├── dto/
│   │   ├── UserDto.java
│   │   ├── CreateUserRequest.java
│   │   ├── UpdateUserRequest.java
│   │   ├── LoginRequest.java
│   │   └── JwtResponse.java
│   ├── exception/
│   │   ├── GlobalExceptionHandler.java
│   │   ├── UserNotFoundException.java
│   │   └── EmailAlreadyExistsException.java
│   └── security/
│       ├── JwtAuthenticationFilter.java
│       ├── UserPrincipal.java
│       └── CustomUserDetailsService.java
└── test/java/com/example/usermanagement/
    ├── controller/
    │   ├── UserControllerTest.java
    │   └── AuthControllerTest.java
    ├── service/
    │   ├── UserServiceTest.java
    │   └── AuthenticationServiceTest.java
    ├── repository/
    │   ├── UserRepositoryTest.java
    │   └── RoleRepositoryTest.java
    └── integration/
        └── UserManagementIntegrationTest.java
```

#### Generated Code Examples

**User Entity** (`src/main/java/com/example/usermanagement/entity/User.java`):

```java
package com.example.usermanagement.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * User entity representing system users
 * 
 * @author Generated by Agnostic Coding Agent
 * @version 1.0
 */
@Entity
@Table(name = "users", 
       uniqueConstraints = @UniqueConstraint(columnNames = "email"))
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity implements UserDetails {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "email", nullable = false, unique = true)
    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is required")
    @Size(max = 100, message = "Email should not exceed 100 characters")
    private String email;
    
    @Column(name = "first_name", nullable = false)
    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name should be between 2 and 50 characters")
    private String firstName;
    
    @Column(name = "last_name", nullable = false)
    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name should be between 2 and 50 characters")
    private String lastName;
    
    @Column(name = "password", nullable = false)
    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password should be at least 8 characters")
    private String password;
    
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles;
    
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
    
    @Column(name = "last_login")
    private LocalDateTime lastLogin;
    
    // UserDetails interface implementation
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return roles.stream()
                .map(role -> new SimpleGrantedAuthority(role.getName()))
                .collect(Collectors.toList());
    }
    
    @Override
    public String getUsername() {
        return email;
    }
    
    @Override
    public boolean isAccountNonExpired() {
        return isActive;
    }
    
    @Override
    public boolean isAccountNonLocked() {
        return isActive;
    }
    
    @Override
    public boolean isCredentialsNonExpired() {
        return isActive;
    }
    
    @Override
    public boolean isEnabled() {
        return isActive;
    }
    
    // Utility methods
    public String getFullName() {
        return firstName + " " + lastName;
    }
    
    public boolean hasRole(String roleName) {
        return roles.stream()
                .anyMatch(role -> role.getName().equals(roleName));
    }
    
    public boolean isAdmin() {
        return hasRole("ROLE_ADMIN");
    }
}
```

**User Controller** (`src/main/java/com/example/usermanagement/controller/UserController.java`):

```java
package com.example.usermanagement.controller;

import com.example.usermanagement.dto.*;
import com.example.usermanagement.entity.User;
import com.example.usermanagement.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller for user management operations
 * 
 * @author Generated by Agnostic Coding Agent
 * @version 1.0
 */
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
@Slf4j
@CrossOrigin(origins = "*", maxAge = 3600)
public class UserController {
    
    private final UserService userService;
    
    /**
     * Get all users with pagination (Admin only)
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Page<UserDto>> getAllUsers(Pageable pageable) {
        log.info("Fetching all users with pagination: {}", pageable);
        Page<UserDto> users = userService.getAllUsers(pageable);
        return ResponseEntity.ok(users);
    }
    
    /**
     * Get user by ID
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or @userSecurity.isOwner(authentication, #id)")
    public ResponseEntity<UserDto> getUserById(@PathVariable Long id) {
        log.info("Fetching user with ID: {}", id);
        UserDto user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
    
    /**
     * Get current user profile
     */
    @GetMapping("/profile")
    public ResponseEntity<UserDto> getCurrentUserProfile(Authentication authentication) {
        log.info("Fetching profile for user: {}", authentication.getName());
        UserDto user = userService.getUserByEmail(authentication.getName());
        return ResponseEntity.ok(user);
    }
    
    /**
     * Create new user (Registration)
     */
    @PostMapping
    public ResponseEntity<UserDto> createUser(@Valid @RequestBody CreateUserRequest request) {
        log.info("Creating new user with email: {}", request.getEmail());
        UserDto createdUser = userService.createUser(request);
        return new ResponseEntity<>(createdUser, HttpStatus.CREATED);
    }
    
    /**
     * Update user
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or @userSecurity.isOwner(authentication, #id)")
    public ResponseEntity<UserDto> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UpdateUserRequest request,
            Authentication authentication) {
        log.info("Updating user with ID: {} by user: {}", id, authentication.getName());
        UserDto updatedUser = userService.updateUser(id, request);
        return ResponseEntity.ok(updatedUser);
    }
    
    /**
     * Delete user (Admin only - soft delete)
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        log.info("Deleting user with ID: {}", id);
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
    
    /**
     * Search users by criteria (Admin only)
     */
    @GetMapping("/search")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Page<UserDto>> searchUsers(
            @RequestParam(required = false) String email,
            @RequestParam(required = false) String firstName,
            @RequestParam(required = false) String lastName,
            @RequestParam(required = false) Boolean isActive,
            Pageable pageable) {
        log.info("Searching users with criteria - email: {}, firstName: {}, lastName: {}, isActive: {}", 
                email, firstName, lastName, isActive);
        
        Page<UserDto> users = userService.searchUsers(email, firstName, lastName, isActive, pageable);
        return ResponseEntity.ok(users);
    }
    
    /**
     * Change user password
     */
    @PutMapping("/{id}/password")
    @PreAuthorize("hasRole('ADMIN') or @userSecurity.isOwner(authentication, #id)")
    public ResponseEntity<Void> changePassword(
            @PathVariable Long id,
            @Valid @RequestBody ChangePasswordRequest request,
            Authentication authentication) {
        log.info("Changing password for user ID: {} by user: {}", id, authentication.getName());
        userService.changePassword(id, request);
        return ResponseEntity.ok().build();
    }
    
    /**
     * Activate/Deactivate user (Admin only)
     */
    @PutMapping("/{id}/status")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserDto> updateUserStatus(
            @PathVariable Long id,
            @RequestParam Boolean isActive) {
        log.info("Updating status for user ID: {} to: {}", id, isActive);
        UserDto updatedUser = userService.updateUserStatus(id, isActive);
        return ResponseEntity.ok(updatedUser);
    }
}
```

**User Service Implementation** (`src/main/java/com/example/usermanagement/service/UserServiceImpl.java`):

```java
package com.example.usermanagement.service;

import com.example.usermanagement.dto.*;
import com.example.usermanagement.entity.Role;
import com.example.usermanagement.entity.User;
import com.example.usermanagement.exception.EmailAlreadyExistsException;
import com.example.usermanagement.exception.InvalidPasswordException;
import com.example.usermanagement.exception.UserNotFoundException;
import com.example.usermanagement.repository.RoleRepository;
import com.example.usermanagement.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Set;

/**
 * User service implementation with comprehensive business logic
 * 
 * @author Generated by Agnostic Coding Agent
 * @version 1.0
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class UserServiceImpl implements UserService {
    
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    private final UserMapper userMapper;
    
    @Override
    @Transactional(readOnly = true)
    public Page<UserDto> getAllUsers(Pageable pageable) {
        log.debug("Fetching all users with pagination");
        Page<User> users = userRepository.findAll(pageable);
        return users.map(userMapper::toDto);
    }
    
    @Override
    @Transactional(readOnly = true)
    public UserDto getUserById(Long id) {
        log.debug("Fetching user with ID: {}", id);
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + id));
        return userMapper.toDto(user);
    }
    
    @Override
    @Transactional(readOnly = true)
    public UserDto getUserByEmail(String email) {
        log.debug("Fetching user with email: {}", email);
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("User not found with email: " + email));
        return userMapper.toDto(user);
    }
    
    @Override
    public UserDto createUser(CreateUserRequest request) {
        log.info("Creating new user with email: {}", request.getEmail());
        
        // Check if user already exists
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new EmailAlreadyExistsException("User already exists with email: " + request.getEmail());
        }
        
        // Create new user
        User user = new User();
        user.setEmail(request.getEmail());
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setIsActive(true);
        
        // Assign default role
        Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseThrow(() -> new RuntimeException("Default role not found"));
        user.setRoles(Set.of(userRole));
        
        User savedUser = userRepository.save(user);
        log.info("Successfully created user with ID: {}", savedUser.getId());
        
        return userMapper.toDto(savedUser);
    }
    
    @Override
    public UserDto updateUser(Long id, UpdateUserRequest request) {
        log.info("Updating user with ID: {}", id);
        
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + id));
        
        // Check email uniqueness if changed
        if (!user.getEmail().equals(request.getEmail()) && 
            userRepository.existsByEmail(request.getEmail())) {
            throw new EmailAlreadyExistsException("Email already exists: " + request.getEmail());
        }
        
        // Update user fields
        user.setEmail(request.getEmail());
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        
        User updatedUser = userRepository.save(user);
        log.info("Successfully updated user with ID: {}", updatedUser.getId());
        
        return userMapper.toDto(updatedUser);
    }
    
    @Override
    public void deleteUser(Long id) {
        log.info("Deleting user with ID: {}", id);
        
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + id));
        
        // Soft delete - mark as inactive
        user.setIsActive(false);
        userRepository.save(user);
        
        log.info("Successfully marked user as inactive with ID: {}", id);
    }
    
    @Override
    public void changePassword(Long id, ChangePasswordRequest request) {
        log.info("Changing password for user ID: {}", id);
        
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + id));
        
        // Verify current password
        if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPassword())) {
            throw new InvalidPasswordException("Current password is incorrect");
        }
        
        // Update password
        user.setPassword(passwordEncoder.encode(request.getNewPassword()));
        userRepository.save(user);
        
        log.info("Successfully changed password for user ID: {}", id);
    }
    
    @Override
    public UserDto updateUserStatus(Long id, Boolean isActive) {
        log.info("Updating status for user ID: {} to: {}", id, isActive);
        
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + id));
        
        user.setIsActive(isActive);
        User updatedUser = userRepository.save(user);
        
        log.info("Successfully updated status for user ID: {}", id);
        return userMapper.toDto(updatedUser);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<UserDto> searchUsers(String email, String firstName, String lastName, 
                                   Boolean isActive, Pageable pageable) {
        log.debug("Searching users with criteria - email: {}, firstName: {}, lastName: {}, isActive: {}", 
                email, firstName, lastName, isActive);
        
        Page<User> users = userRepository.findByCriteria(email, firstName, lastName, isActive, pageable);
        return users.map(userMapper::toDto);
    }
    
    @Override
    public void updateLastLogin(String email) {
        log.debug("Updating last login time for user: {}", email);
        
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("User not found with email: " + email));
        
        user.setLastLogin(LocalDateTime.now());
        userRepository.save(user);
    }
}
```

### Example 2: E-commerce Product Catalog

#### Feature Specification

```markdown
# E-commerce Product Catalog API

## Feature Request
Create a comprehensive product catalog system for an e-commerce platform with category management, inventory tracking, and search capabilities.

## Technical Requirements
- Spring Boot 3.x with Spring Web and Spring Data JPA
- Elasticsearch integration for product search
- Redis for caching frequently accessed data
- File upload support for product images
- Audit logging for price changes
- Comprehensive validation and error handling

## Data Models
- Product (name, description, price, SKU, category, inventory)
- Category (name, description, parent category for hierarchy)
- ProductImage (product association, image URL, display order)
- ProductReview (user, product, rating, comment)
- Inventory (product, quantity, reserved, reorder level)
```

This example would generate:
- Product entity with complex relationships
- Category hierarchy management
- Inventory tracking service
- Search integration with Elasticsearch
- File upload handling for product images
- Comprehensive REST API with search, filtering, and pagination

### Example 3: Order Management System

#### Feature Specification

```markdown
# Order Management System

## Feature Request
Implement a complete order processing system with state management, payment integration, and notification capabilities.

## Technical Requirements
- Order state machine (PENDING → CONFIRMED → PROCESSING → SHIPPED → DELIVERED)
- Payment integration with external service
- Email notifications for order status changes
- Inventory reservation during order processing
- Order audit trail and history tracking
```

This example would generate:
- Order entity with state management
- Order state machine implementation
- Payment service integration
- Email notification service
- Inventory reservation logic
- Comprehensive order processing workflow

## Key Patterns Demonstrated

### 1. Entity Design Patterns
- **Base Entity**: Common fields (id, createdAt, updatedAt)
- **Audit Trail**: Automatic timestamp management
- **Soft Delete**: Mark records as inactive instead of physical deletion
- **Validation**: Comprehensive Bean Validation annotations

### 2. Repository Patterns
- **Custom Query Methods**: Method name-based query generation
- **Criteria API**: Dynamic query building
- **Specification Pattern**: Reusable query specifications
- **Pagination Support**: Built-in Spring Data pagination

### 3. Service Layer Patterns
- **Interface Segregation**: Service interfaces with implementations
- **Transaction Management**: Declarative transaction boundaries
- **Exception Handling**: Custom business exceptions
- **Logging Strategy**: Structured logging with appropriate levels

### 4. Controller Patterns
- **RESTful Design**: Standard HTTP methods and status codes
- **Security Integration**: Method-level security with SpEL
- **Input Validation**: Request DTO validation
- **Response Mapping**: Consistent API response structure

### 5. Security Patterns
- **JWT Authentication**: Stateless token-based authentication
- **Role-Based Access**: Flexible role and permission system
- **Method Security**: Fine-grained access control
- **CORS Configuration**: Cross-origin resource sharing setup

## Testing Patterns

### Unit Testing Example

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private PasswordEncoder passwordEncoder;
    
    @InjectMocks
    private UserServiceImpl userService;
    
    @Test
    void createUser_ValidRequest_Success() {
        // Given
        CreateUserRequest request = new CreateUserRequest();
        request.setEmail("test@example.com");
        request.setFirstName("John");
        request.setLastName("Doe");
        request.setPassword("password123");
        
        when(userRepository.existsByEmail(request.getEmail())).thenReturn(false);
        when(passwordEncoder.encode(request.getPassword())).thenReturn("encodedPassword");
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> {
            User user = invocation.getArgument(0);
            user.setId(1L);
            return user;
        });
        
        // When
        UserDto result = userService.createUser(request);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getEmail()).isEqualTo("test@example.com");
        assertThat(result.getFirstName()).isEqualTo("John");
        assertThat(result.getLastName()).isEqualTo("Doe");
        
        verify(userRepository).existsByEmail(request.getEmail());
        verify(passwordEncoder).encode(request.getPassword());
        verify(userRepository).save(any(User.class));
    }
    
    @Test
    void createUser_EmailExists_ThrowsException() {
        // Given
        CreateUserRequest request = new CreateUserRequest();
        request.setEmail("existing@example.com");
        
        when(userRepository.existsByEmail(request.getEmail())).thenReturn(true);
        
        // When & Then
        assertThatThrownBy(() -> userService.createUser(request))
                .isInstanceOf(EmailAlreadyExistsException.class)
                .hasMessage("User already exists with email: existing@example.com");
                
        verify(userRepository).existsByEmail(request.getEmail());
        verify(userRepository, never()).save(any(User.class));
    }
}
```

### Integration Testing Example

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class UserControllerIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
            
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void createUser_ValidRequest_ReturnsCreatedUser() {
        // Given
        CreateUserRequest request = new CreateUserRequest();
        request.setEmail("integration@example.com");
        request.setFirstName("Integration");
        request.setLastName("Test");
        request.setPassword("password123");
        
        // When
        ResponseEntity<UserDto> response = restTemplate.postForEntity(
                "/api/users", request, UserDto.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getEmail()).isEqualTo("integration@example.com");
        
        // Verify in database
        Optional<User> savedUser = userRepository.findByEmail("integration@example.com");
        assertThat(savedUser).isPresent();
    }
}
```

These examples demonstrate how the Framework-Agnostic Coding Agent generates comprehensive, production-ready Spring Boot applications following best practices and industry standards.